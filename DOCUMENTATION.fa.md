<div dir="rtl" style="text-align: right; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6;">

# مستندات فریم‌ورک میکرو پایتون

## معرفی
این یک فریم‌ورک میکرو است که **به طور انحصاری برای اهداف آموزشی** طراحی شده است تا به مبتدیان در درک اصول اولیه پایتون و توسعه RESTful API کمک کند. این فریم‌ورک از معماری ساده MVC (Model-View-Controller) استفاده می‌کند و قابلیت‌های پایه‌ای RESTful API را فراهم می‌کند.

> ⚠️ **نکته مهم**: این فریم‌ورک **مناسب استفاده در محیط تولید نیست**. این فریم‌ورک صرفاً به عنوان ابزار آموزشی طراحی شده است تا به شما در درک موارد زیر کمک کند:
> - نحوه کار فریم‌ورک‌هایی مانند Django و FastAPI
> - اصول OOP پایتون و الگوهای طراحی
> - معماری لایه‌ای و جداسازی مسئولیت‌ها
> - اصول پایه‌ای REST API و مدیریت درخواست‌های HTTP
> - عملیات پایگاه داده و مفاهیم ORM
> - پیاده‌سازی پایه‌ای معماری MVC

> ⚠️ **هشدار امنیتی**: این فریم‌ورک **پیاده‌سازی امنیتی حداقلی** دارد و هرگز نباید در محیط‌های تولید استفاده شود. این فریم‌ورک فاقد موارد زیر است:
> - احراز هویت و مجوزدهی مناسب
> - پاکسازی ورودی
> - محافظت در برابر CSRF
> - محدودیت نرخ درخواست
> - مدیریت خطای مناسب برای محیط تولید
> - هدرهای امنیتی
> - و بسیاری از ویژگی‌های امنیتی ضروری دیگر

این فریم‌ورک به عنوان یک گام اولیه عالی برای یادگیری اصول REST API و درک ساختار فریم‌ورک‌های وب عمل می‌کند، اما باید به عنوان یک ابزار آموزشی و نه یک راه‌حل آماده تولید در نظر گرفته شود.

## پیش‌نیازها
- پایتون 3.13.2 یا بالاتر
- محیط مجازی (توصیه می‌شود)

## نصب و راه‌اندازی

> ⚠️ **مهم**: همیشه محیط مجازی را بلافاصله پس از کلون کردن مخزن و قبل از نصب هرگونه وابستگی ایجاد و فعال کنید. این کار یک محیط تمیز و ایزوله برای پروژه شما فراهم می‌کند.

1. کلون کردن مخزن:
   ```bash
   git clone https://github.com/secure73/micro_py_framework.git
   ```
2. رفتن به پوشه محلی کلون شده، به عنوان مثال micro_py_framework پوشه هدف محلی شما است که مخزن در آن کلون شده است:
   ```bash
   cd micro_py_framework
   ```

4.  ⚠️ **مهم** ایجاد و فعال‌سازی محیط مجازی درون پوشه پروژه (مهم - این کار را بلافاصله پس از کلون کردن انجام دهید):
   ```bash
   # ویندوز
   python -m venv venv
   .\venv\Scripts\activate

   # لینوکس/مک
   python -m venv venv
   source venv/bin/activate

   # بررسی فعال‌سازی (باید مسیر محیط مجازی را نمایش دهد)
   # ویندوز: where python
   # لینوکس/مک: which python
   ```

5. نصب وابستگی‌ها:
   ```bash
   # نصب وابستگی‌ها
   pip install -r requirements.txt
   ```

6. مهاجرت پایگاه داده:
   ```bash
   # اجرای مهاجرت پایگاه داده
   python migrate.py

   # راه‌اندازی برنامه
   python app.py   # سرور روی پورت 8001 شروع می‌شود
   ```
7. اجرای برنامه:
   ```bash
   # راه‌اندازی برنامه
   python app.py   # سرور روی پورت 8001 شروع می‌شود
   ```

### عیب‌یابی محیط مجازی
1. **فعال نشدن محیط مجازی**:
   - بررسی نصب پایتون
   - اطمینان از اینکه سیاست اجرا اجازه اجرای اسکریپت‌ها را می‌دهد (ویندوز)
   - تلاش برای ایجاد یک محیط مجازی جدید

2. **شکست در نصب بسته‌ها**:
   - بررسی فعال بودن محیط مجازی
   - بررسی اتصال اینترنت
   - به‌روزرسانی pip: `python -m pip install --upgrade pip`

3. **نسخه اشتباه پایتون**:
   - حذف محیط مجازی
   - ایجاد محیط جدید با نسخه صحیح پایتون
   - نصب مجدد وابستگی‌ها

## ساختار پروژه
```
micro_py_framework/
├── app.py                 # نقطه ورود اصلی برنامه
├── controller/            # پوشه کنترلرها
│   ├── UserController.py  # عملیات مربوط به کاربر
│   └── AutoController.py  # عملیات مربوط به خودرو
├── model/                # پوشه مدل‌ها
│   ├── UserModel.py      # عملیات داده کاربر
│   └── AutoModel.py      # عملیات داده خودرو
├── table/                # جداول پایگاه داده
│   ├── DBConnection.py   # مدیریت اتصال پایگاه داده
│   ├── DBMigrate.py      # مهاجرت و طرح پایگاه داده
│   ├── UserTable.py      # طرح جدول کاربر
│   └── AutoTable.py      # طرح جدول خودرو
├── interface/            # پوشه رابط‌ها
│   └── IController.py    # رابط کنترلر
└── helper/              # ابزارهای کمکی
    ├── HttpHandler.py    # مدیریت درخواست HTTP
    ├── Response.py       # فرمت‌بندی پاسخ
    ├── JWTManager.py     # احراز هویت JWT
    ├── FormatCheck.py    # اعتبارسنجی ورودی
    ├── CodeAssistant.py  # تولید کد با هوش مصنوعی
    └── DatabaseMigration.py  # کمک‌کننده مهاجرت پایگاه داده
```

## نقاط پایانی API

### نقاط پایانی کنترلر کاربر

1. **ایجاد کاربر**
   - متد: POST
   - URL: `/user`
   - بدنه درخواست:
     ```json
     {
         "email": "user@example.com",
         "password": "password123",
         "name": "John Doe"
     }
     ```
   - پاسخ: پیام موفقیت یا جزئیات خطا

2. **دریافت کاربر(ها)**
   - متد: GET
   - URL: `/user` (لیست تمام کاربران)
   - URL: `/user/{id}` (دریافت کاربر خاص)
   - پاسخ: داده کاربر یا پیام خطا

3. **به‌روزرسانی کاربر**
   - متد: PUT
   - URL: `/user`
   - بدنه درخواست:
     ```json
     {
         "id": 1,
         "name": "نام به‌روز شده",
         "password": "رمز جدید"  // اختیاری
     }
     ```
   - پاسخ: داده کاربر به‌روز شده یا پیام خطا

4. **حذف کاربر**
   - متد: DELETE
   - URL: `/user`
   - بدنه درخواست:
     ```json
     {
         "id": 1
     }
     ```
   - پاسخ: پیام موفقیت یا جزئیات خطا

### نقاط پایانی کنترلر خودرو

1. **ایجاد خودرو**
   - متد: POST
   - URL: `/auto`
   - بدنه درخواست:
     ```json
     {
         "name": "مرسدس بنز",
         "ps": 750
     }
     ```
   - پاسخ: پیام موفقیت یا جزئیات خطا

2. **دریافت خودرو(ها)**
   - متد: GET
   - URL: `/auto` (لیست تمام خودروها)
   - URL: `/auto/{id}` (دریافت خودرو خاص)
   - پاسخ: داده خودرو یا پیام خطا

3. **به‌روزرسانی خودرو**
   - متد: PUT
   - URL: `/auto`
   - بدنه درخواست:
     ```json
     {
         "id": 1,
         "name": "نام به‌روز شده",
         "ps": 800
     }
     ```
   - پاسخ: داده خودرو به‌روز شده یا پیام خطا

4. **حذف خودرو**
   - متد: DELETE
   - URL: `/auto`
   - بدنه درخواست:
     ```json
     {
         "id": 1
     }
     ```
   - پاسخ: پیام موفقیت یا جزئیات خطا

## اعتبارسنجی داده

### قوانین اعتبارسنجی داده کاربر
- ایمیل: باید از فرمت استاندارد ایمیل پیروی کند
- رمز عبور: حداقل 6 کاراکتر
- نام: حداقل 2 کاراکتر

### قوانین اعتبارسنجی داده خودرو
- نام: حداقل 2 کاراکتر
- اسب بخار: باید یک عدد صحیح مثبت باشد

## پایگاه داده

### پایگاه داده SQLite
- برنامه از SQLite به عنوان پایگاه داده پیش‌فرض استفاده می‌کند
- فایل پایگاه داده: `db.db`
- جداول به صورت خودکار در اولین اجرا ایجاد می‌شوند

### مهاجرت پایگاه داده (DatabaseMigration.py)
فایل `DatabaseMigration.py` مسئول مقداردهی اولیه خودکار پایگاه داده و ایجاد جداول است. این فایل موارد زیر را مدیریت می‌کند:

1. **اتصال پایگاه داده**
   - ایجاد اتصال به پایگاه داده SQLite (`db.db`)
   - مدیریت مکان‌نما پایگاه داده برای اجرای دستورات SQL
   - استفاده از SQLAlchemy برای عملیات پایگاه داده

2. **ایجاد خودکار جداول**
   - کشف و ایجاد خودکار تمام جداول تعریف شده در پوشه `table`
   - استفاده از مدل‌های SQLAlchemy برای تعریف ساختار جدول
   - در حال حاضر جداول زیر را مدیریت می‌کند:
     - `users`: ذخیره اطلاعات کاربر با ایمیل، رمز عبور و نام
     - `autos`: ذخیره اطلاعات خودرو با نام و اسب بخار
   - نیازی به ایجاد دستی SQL نیست - جداول از تعاریف مدل ایجاد می‌شوند

3. **ویژگی‌های مهاجرت**
   - کشف و ایجاد خودکار جداول
   - تشخیص تغییرات ستون‌ها
   - پیگیری وضعیت مهاجرت
   - شاخص‌های پیشرفت واضح با ایموجی‌ها
   - خلاصه مهاجرت دقیق
   - مثال خروجی:
     ```
     🚀 شروع مهاجرت پایگاه داده...
     📝 ایجاد جدول: users
     📝 ایجاد جدول: autos
     
     ✅ جداول با موفقیت ایجاد شدند:
       - users
       - autos
     
     === خلاصه مهاجرت ===
     📦 جداول ایجاد شده:
       ✓ users
       ✓ autos
     
     ✨ فرآیند مهاجرت تکمیل شد!
     ```

4. **اسکریپت مهاجرت (migrate.py)**
   به سادگی فایل migrate.py را در ریشه باز کنید و اجرا کنید، یا در ترمینال در ریشه پروژه بنویسید python migrate.py!
   
   ویژگی‌ها:
   - ایجاد خودکار جداول از تعاریف مدل
   - پیگیری نسخه طرح
   - تشخیص تغییرات ستون
   - شاخص‌های پیشرفت واضح
   - تولید خلاصه مهاجرت
   - مدیریت خطا با پیام‌های توصیفی

5. **مزایای کلیدی**
   - نیازی به نوشتن دستی SQL نیست
   - طرح پایگاه داده یکسان در تمام نصب‌ها
   - به‌روزرسانی خودکار طرح هنگام تغییر مدل‌ها
   - بازخورد واضح در طول فرآیند مهاجرت
   - تشخیص و گزارش خطا
   - فرآیند مهاجرت ایمن با پشتیبانی از بازگشت

### مدیریت اتصال پایگاه داده (DBConnection.py)
فایل `DBConnection.py` اتصالات پایگاه داده را با استفاده از SQLAlchemy ORM مدیریت می‌کند. این فایل موارد زیر را فراهم می‌کند:

1. **ادغام SQLAlchemy**
   - استفاده از SQLAlchemy برای Object-Relational Mapping (ORM)
   - فراهم کردن پایه اعلانی برای تعاریف مدل
   - مدیریت کارآمد نشست‌های پایگاه داده

2. **پیکربندی اتصال**
   ```python
   engine = create_engine("sqlite:///db.db", echo=False)
   ```
   - پیکربندی پیش‌فرض از پایگاه داده SQLite استفاده می‌کند
   - پشتیبانی از MySQL/MariaDB از طریق تغییر رشته اتصال
   - `echo=False` ثبت درخواست‌های SQL را برای عملکرد بهتر غیرفعال می‌کند

3. **مدیریت نشست**
   ```python
   Session = sessionmaker(bind=engine)
   ```
   - ایجاد کارخانه نشست برای عملیات پایگاه داده
   - مدیریت اتصالات و تراکنش‌های پایگاه داده
   - فراهم کردن دسترسی امن به پایگاه داده در محیط چند نخی

4. **پشتیبانی پایگاه داده**
   - **SQLite** (پیش‌فرض):
     ```python
     engine = create_engine("sqlite:///db.db")
     ```
   - **MySQL/MariaDB**:
     ```python
     engine = create_engine("mysql+pymysql://نام_کاربر:رمز_عبور@localhost:3306/نام_پایگاه_داده")
     ```

5. **مدیریت خطا**
   - گرفتن و گزارش خطاهای اتصال پایگاه داده
   - فراهم کردن پیام‌های خطای واضح برای عیب‌یابی

6. **استفاده در مدل‌ها**
   ```python
   from table.DBConnection import DBConnection
   
   class مدل_شما:
       def __init__(self):
           self.Session = DBConnection.Session
   ```

7. **بهترین روش‌ها**
   - استفاده از اتصال‌دهی برای عملکرد بهتر
   - پیاده‌سازی مدیریت نشست مناسب
   - پشتیبانی از چندین بک‌اند پایگاه داده
   - پیروی از بهترین روش‌های SQLAlchemy

### پشتیبانی MySQL
- این فریم‌ورک از پایگاه داده‌های MySQL نیز پشتیبانی می‌کند
- برای استفاده از MySQL، رشته اتصال را در `table/DBConnection.py` تغییر دهید:
  ```python
  engine = create_engine("mysql+pymysql://نام_کاربر:رمز_عبور@localhost:3306/نام_پایگاه_داده")
  ```

## مدیریت خطا
این فریم‌ورک شامل مدیریت خطای جامع برای موارد زیر است:
- داده ورودی نامعتبر
- عملیات پایگاه داده
- اعتبارسنجی درخواست HTTP
- منبع یافت نشد
- اعتبارسنجی نوع داده
- فیلدهای اجباری گم شده

## نکات امنیتی
1. این یک فریم‌ورک آموزشی است و برای استفاده در محیط تولید توصیه نمی‌شود
2. هش کردن رمز عبور با استفاده از bcrypt پیاده‌سازی شده است
3. اعتبارسنجی ورودی پایه از طریق FormatCheck.py فراهم شده است
4. پشتیبانی از احراز هویت JWT از طریق JWTManager.py در دسترس است
5. هیچ سیستم احراز هویت/مجوزدهی داخلی وجود ندارد

## اعتبارسنجی ورودی
این فریم‌ورک شامل یک ابزار FormatCheck برای اعتبارسنجی داده ورودی است:

1. **اعتبارسنجی ایمیل**
   ```python
   FormatCheck.email("user@example.com")
   ```
   - استفاده از الگوی regex: `^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-z]+$`
   - اعتبارسنجی:
     - بخش نام کاربری: حروف، اعداد، نقطه، زیرخط، علامت مثبت، خط تیره
     - بخش دامنه: حروف، اعداد، خط تیره
     - TLD: فقط حروف
   - برمی‌گرداند: True اگر معتبر باشد، False در غیر این صورت

2. **اعتبارسنجی طول**
   ```python
   FormatCheck.minimumLength("رمز عبور", 6)
   ```
   - بررسی می‌کند که رشته حداقل طول مورد نیاز را دارد
   - پارامترها:
     - input_string: رشته برای اعتبارسنجی
     - min_length: حداقل طول مورد نیاز
   - برمی‌گرداند: True اگر طول >= min_length باشد، False در غیر این صورت

3. **مثال‌های استفاده**
   ```python
   # اعتبارسنجی ایمیل
   if not FormatCheck.email(user_email):
       return Response.bad_request("فرمت ایمیل نامعتبر است")

   # بررسی طول رمز عبور
   if not FormatCheck.minimumLength(رمز_عبور, 6):
       return Response.bad_request("رمز عبور باید حداقل 6 کاراکتر باشد")

   # بررسی طول نام
   if not FormatCheck.minimumLength(نام, 2):
       return Response.bad_request("نام باید حداقل 2 کاراکتر باشد")
   ```

4. **قوانین اعتبارسنجی**
   - ایمیل: باید از فرمت استاندارد ایمیل با کاراکترهای معتبر پیروی کند
   - رمز عبور: حداقل 6 کاراکتر
   - نام: حداقل 2 کاراکتر

## مثال استفاده

### ایجاد یک خودرو جدید
```bash
curl -X POST http://localhost:8001/auto \
  -H "Content-Type: application/json" \
  -d '{"name": "مرسدس بنز", "ps": 750}'
```

### دریافت تمام خودروها
```bash
curl http://localhost:8001/auto
```

### دریافت یک خودرو خاص
```bash
curl http://localhost:8001/auto/1
```

### به‌روزرسانی یک خودرو
```bash
curl -X PUT http://localhost:8001/auto \
  -H "Content-Type: application/json" \
  -d '{"id": 1, "name": "نام به‌روز شده", "ps": 800}'
```

### حذف یک خودرو
```bash
curl -X DELETE http://localhost:8001/auto \
  -H "Content-Type: application/json" \
  -d '{"id": 1}'
```

## مجموعه Postman
این فریم‌ورک شامل یک مجموعه Postman (`Micro Python.postman_collection.json`) است که درخواست‌های از پیش پیکربندی شده برای نقاط پایانی API نمونه را شامل می‌شود. این کار تست API را بدون نیاز به نوشتن دستورات curl آسان می‌کند.

### وارد کردن مجموعه
1. Postman را باز کنید
2. روی دکمه "Import" در گوشه بالا سمت چپ کلیک کنید
3. تب "File" را انتخاب کنید
4. روی "Upload Files" کلیک کنید و `Micro Python.postman_collection.json` را انتخاب کنید
5. روی "Import" کلیک کنید

### استفاده از مجموعه
این مجموعه شامل درخواست‌های از پیش پیکربندی شده زیر است:

#### نقاط پایانی خودرو
- **GET /auto**: لیست تمام خودروها
- **POST /auto**: ایجاد یک خودرو جدید
  - Body: JSON با فیلدهای `name` و `ps`
- **PUT /auto**: به‌روزرسانی یک خودرو موجود
  - Body: JSON با فیلدهای `id`، `name` و `ps`
- **DELETE /auto**: حذف یک خودرو
  - Body: JSON با فیلد `id`

### ویژگی‌های مجموعه
- هدرهای از پیش پیکربندی شده (Content-Type: application/json)
- بدنه درخواست نمونه
- ساختار پوشه سازمان‌یافته
- پشتیبانی از متغیرهای محیطی
- مستندات برای هر نقطه پایانی

### نکات برای استفاده از Postman
1. **راه‌اندازی محیط**
   - ایجاد یک محیط جدید
   - اضافه کردن متغیر `base_url` با مقدار `http://localhost:8001`
   - استفاده از `{{base_url}}` در URL درخواست‌ها

2. **گردش کار تست**
   - شروع با درخواست‌های GET برای مشاهده داده
   - استفاده از POST برای ایجاد ورودی‌های جدید
   - استفاده از PUT برای تغییر ورودی‌های موجود
   - استفاده از DELETE برای حذف ورودی‌ها

3. **مدیریت پاسخ**
   - بررسی کدهای وضعیت
   - مشاهده پاسخ‌های JSON فرمت شده
   - استفاده از اسکریپت‌های تست Postman برای خودکارسازی

## دستورالعمل‌های توسعه

### ایجاد کنترلرهای جدید
1. ایجاد یک فایل جدید در پوشه `controller`
2. پیاده‌سازی رابط `IController`
3. اضافه کردن متدهای کنترلر (get, post, put, destroy)

### ایجاد مدل‌های جدید
1. ایجاد یک فایل جدید در پوشه `model`
2. پیاده‌سازی رابط `IModel`
3. ایجاد جدول مربوطه در پوشه `table`
4. پیاده‌سازی عملیات پایگاه داده

## محدودیت‌ها
1. هیچ سیستم احراز هویت داخلی وجود ندارد
2. مدیریت خطای محدود
3. اعتبارسنجی ورودی پایه
4. هیچ محدودیت نرخ درخواست وجود ندارد
5. هیچ سیستم ثبت داخلی وجود ندارد
6. هیچ مکانیزم کش داخلی وجود ندارد

## بهترین روش‌ها
1. همیشه از محیط مجازی استفاده کنید
2. کنترلرها را سبک نگه دارید، منطق کسب و کار را به مدل‌ها منتقل کنید
3. داده ورودی را قبل از پردازش اعتبارسنجی کنید
4. خطاهای پایگاه داده را به درستی مدیریت کنید
5. از کدهای وضعیت HTTP مناسب در پاسخ‌ها استفاده کنید
6. از الگوهای مدیریت خطای سازگار پیروی کنید
7. از نکات نوع برای وضوح بهتر کد استفاده کنید
8. نقاط پایانی API و نیازمندی‌های آن‌ها را مستند کنید

## عیب‌یابی
1. اگر اتصال پایگاه داده شکست خورد:
   - بررسی کنید که فایل پایگاه داده وجود دارد
   - اعتبارنامه‌های پایگاه داده را تأیید کنید (در صورت استفاده از MySQL)
   - مجوزهای پایگاه داده را بررسی کنید

2. اگر سرور راه‌اندازی نشد:
   - بررسی کنید که پورت 8001 در دسترس است
   - تأیید کنید که تمام وابستگی‌ها نصب شده‌اند
   - سازگاری نسخه پایتون را بررسی کنید

3. اگر درخواست‌ها شکست خوردند:
   - فرمت درخواست را تأیید کنید
   - قوانین اعتبارسنجی ورودی را بررسی کنید
   - اطمینان حاصل کنید که متد HTTP مناسب استفاده شده است
   - تأیید کنید که هدر content-type به درستی تنظیم شده است
   - بررسی کنید که فیلدهای اجباری ارائه شده‌اند

## چرخه حیات درخواست HTTP

### جریان کلی درخواست
```mermaid
graph TD
    A[درخواست کلاینت] --> B[HttpHandler]
    B --> C{اعتبارسنجی درخواست}
    C -->|معتبر| D[مسیریابی به کنترلر]
    C -->|نامعتبر| E[برگرداندن خطای 400]
    D --> F[اجرای متد کنترلر]
    F --> G[پردازش عملیات مدل]
    G --> H[عملیات پایگاه داده]
    H --> I[فرمت‌بندی پاسخ]
    I --> J[ارسال پاسخ به کلاینت]
```

### جریان ایجاد کاربر
```mermaid
sequenceDiagram
    participant کلاینت
    participant HttpHandler
    participant UserController
    participant UserModel
    participant پایگاه_داده

    کلاینت->>HttpHandler: POST /user
    Note over HttpHandler: اعتبارسنجی درخواست
    HttpHandler->>UserController: مسیریابی به کنترلر
    UserController->>UserModel: create()
    UserModel->>UserModel: اعتبارسنجی ایمیل
    UserModel->>UserModel: هش کردن رمز عبور
    UserModel->>پایگاه_داده: درخواست INSERT
    پایگاه_داده-->>UserModel: موفقیت
    UserModel-->>UserController: موفقیت
    UserController-->>HttpHandler: 200 OK
    HttpHandler-->>کلاینت: پاسخ
```

### جریان مدیریت خطا
```mermaid
graph TD
    A[خطا رخ می‌دهد] --> B{نوع خطا}
    B -->|اعتبارسنجی| C[فرمت‌بندی خطای اعتبارسنجی]
    B -->|پایگاه داده| D[فرمت‌بندی خطای پایگاه داده]
    B -->|پیدا نشد| E[فرمت‌بندی خطای 404]
    C --> F[تنظیم کد وضعیت خطا]
    D --> F
    E --> F
    F --> G[ارسال پاسخ خطا]
```

### تعامل مؤلفه‌ها
```mermaid
graph LR
    A[HttpHandler] -->|مسیریابی| B[کنترلر]
    B -->|استفاده می‌کند| C[مدل‌ها]
    C -->|تعامل می‌کند| D[پایگاه داده]
    B -->|پیاده‌سازی می‌کند| E[رابط IController]
    C -->|پیاده‌سازی می‌کند| F[رابط IModel]
    D -->|مدیریت می‌شود توسط| G[DBConnection]
    D -->|طرح توسط| H[DBMigrate]
```

## فرمت پاسخ
تمام پاسخ‌های API از یک فرمت سازگار پیروی می‌کنند:

### پاسخ موفقیت
```json
{
    "status_code": 200,
    "status": "success",
    "message": {
        // داده پاسخ
    }
}
```

### پاسخ خطا
```json
{
    "status_code": 400,
    "status": "error",
    "message": "توضیح خطا"
}
```

## ادغام VS Code
این فریم‌ورک شامل ویژگی‌های ادغام VS Code است:
1. اسنیپت‌های سفارشی برای تولید سریع کد
2. پشتیبانی IntelliSense برای مؤلفه‌های فریم‌ورک
3. افزونه‌های توصیه شده برای توسعه پایتون
4. فرمت‌بندی خودکار کد با Black
5. Linting با Pylint
6. سازماندهی import
7. پشتیبانی از تولید مستندات

## ویژگی‌های دستیار هوش مصنوعی

این فریم‌ورک شامل یک دستیار کد هوشمند است که می‌تواند به شما در موارد زیر کمک کند:
- تولید نقاط پایانی CRUD
- ارائه پیشنهادات کد
- تولید مستندات
- تحلیل کدبیس شما

### شروع کار با دستیار هوش مصنوعی

1. **اجرای دمو دستیار هوش مصنوعی**
   به سادگی فایل `ai.py` را در ترمینال خود اجرا کنید:
   ```bash
   python ai.py
   ```
   این کار به شما نمونه‌هایی از قابلیت‌های دستیار را نشان می‌دهد:
   - تولید نقاط پایانی CRUD برای منبع "Product"
   - نمایش پیشنهادات کد برای UserController
   - تولید مستندات برای کنترلرها

2. **درک خروجی دمو**
   وقتی `ai.py` را اجرا می‌کنید، خواهید دید:
   - نتایج تحلیل کدبیس
   - نقاط پایانی CRUD تولید شده برای یک منبع نمونه
   - پیشنهادات کد برای کارهای رایج
   - نمونه‌های مستندات تولید شده

3. **استفاده از کد تولید شده**
   دمو نمونه‌های کد کامل تولید می‌کند که می‌توانید:
   - در کنترلرهای خود کپی و استفاده کنید
   - به عنوان الگو برای منابع جدید استفاده کنید
   - برای درک الگوهای فریم‌ورک مطالعه کنید

4. **تولید مستندات**
   همچنین می‌توانید مستندات را برای مؤلفه‌های خاص تولید کنید:
   ```python
   # مثال: تولید مستندات برای کنترلرها
   docs = assistant.generate_documentation("controller")
   print(docs)
   ```

### نکات مهم
- دستیار کدبیس شما را تحلیل می‌کند تا پیشنهادات مرتبط با زمینه ارائه دهد
- Generated code should be reviewed and customized for your specific needs
- The assistant is designed for educational purposes and may not cover all edge cases
- Always test generated code before using it in production

### گردش کار نمونه
1. Run `python ai.py` to see examples
2. Review the generated code and documentation
3. Use the patterns shown to create your own resources
4. Get code suggestions when needed
5. Generate documentation for your code
6. Review and customize the generated code
7. Test your implementation

Remember: This is an educational framework. Always review generated code and understand what it does before using it in your project.

## پیامی از توسعه‌دهنده

با تشکر از شما برای زمانی که صرف کاوش در این فریم‌ورک آموزشی کردید! من این پروژه را برای کمک به مبتدیان در درک مفاهیم اساسی توسعه وب و برنامه‌نویسی پایتون ایجاد کردم.

امیدوارم این فریم‌ورک به عنوان یک گام مفید در سفر یادگیری شما عمل کند. به یاد داشته باشید که هر متخصصی زمانی مبتدی بوده است، و کلید تسلط بر برنامه‌نویسی تمرین مداوم و کنجکاوی است.

موفق باشید در سفر یادگیری شما!

علی خرسندفرد
توسعه‌دهنده و مربی
</div>