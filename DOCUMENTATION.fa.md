<div dir="rtl" style="text-align: right; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6;">

# مستندات فریم‌ورک میکرو پایتون

## مرور کلی
این یک فریم‌ورک میکرو است که **به طور انحصاری برای اهداف آموزشی** طراحی شده است تا به مبتدیان در درک اصول اولیه پایتون و توسعه RESTful API کمک کند. این فریم‌ورک معماری ساده MVC (Model-View-Controller) را پیاده‌سازی می‌کند و عملکرد پایه RESTful API را فراهم می‌کند.

> ⚠️ **نکته مهم**: این فریم‌ورک **مناسب برای استفاده در محیط تولید نیست**. این فریم‌ورک صرفاً به عنوان یک ابزار یادگیری طراحی شده است تا به شما در درک موارد زیر کمک کند:
> - نحوه کار فریم‌ورک‌هایی مانند Django و FastAPI
> - اصول OOP پایتون و الگوهای طراحی
> - معماری لایه‌ای و جداسازی مسئولیت‌ها
> - اصول اولیه REST API و مدیریت درخواست‌های HTTP
> - عملیات پایگاه داده و مفاهیم ORM
> - پیاده‌سازی معماری پایه MVC

> ⚠️ **هشدار امنیتی**: این فریم‌ورک **پیاده‌سازی‌های امنیتی حداقلی** دارد و هرگز نباید در محیط‌های تولید استفاده شود. این فریم‌ورک فاقد موارد زیر است:
> - احراز هویت و مجوزدهی مناسب
> - پاکسازی ورودی
> - محافظت در برابر CSRF
> - محدودیت نرخ درخواست
> - مدیریت خطای مناسب برای محیط تولید
> - هدرهای امنیتی
> - و بسیاری از ویژگی‌های امنیتی ضروری دیگر

این فریم‌ورک به عنوان یک گام عالی برای یادگیری اصول REST API و درک نحوه ساختار فریم‌ورک‌های وب عمل می‌کند، اما باید به عنوان یک ابزار یادگیری و نه یک راه‌حل آماده برای تولید در نظر گرفته شود.

## پیش‌نیازها
- پایتون 3.13.2 یا بالاتر
- محیط مجازی (توصیه می‌شود)

## نصب و راه‌اندازی

> ⚠️ **مهم**: همیشه محیط مجازی را بلافاصله پس از کلون کردن مخزن و قبل از نصب هرگونه وابستگی ایجاد و فعال کنید. این امر یک محیط تمیز و ایزوله برای پروژه شما تضمین می‌کند.

1. کلون کردن مخزن:
   ```bash
   git clone https://github.com/secure73/micro_py_framework.git
   ```
2. رفتن به پوشه محلی کلون شده، به عنوان مثال micro_py_framework پوشه هدف محلی شما است که مخزن در آن کلون شده است:
   ```bash
   cd micro_py_framework
   ```

4.  ⚠️ **مهم** ایجاد و فعال کردن محیط مجازی در پوشه پروژه (مهم - این کار را بلافاصله پس از کلون کردن انجام دهید):
   ```bash
   # ویندوز
   python -m venv venv
   .\venv\Scripts\activate

   # لینوکس/مک
   python -m venv venv
   source venv/bin/activate

   # تأیید فعال‌سازی (باید مسیر محیط مجازی را نمایش دهد)
   # ویندوز: where python
   # لینوکس/مک: which python
   ```

5. نصب وابستگی‌ها:
   ```bash
   # نصب وابستگی‌ها
   pip install -r requirements.txt
   ```

6. مهاجرت پایگاه داده:
   ```bash
   # اجرای مهاجرت پایگاه داده
   python migrate.py
   ```
7. اجرای برنامه:
   ```bash
   # راه‌اندازی برنامه
   python app.py   # سرور روی پورت 8001 شروع می‌شود
   ```

### عیب‌یابی محیط مجازی
1. **فعال نشدن محیط مجازی**:
   - بررسی نصب پایتون
   - اطمینان از اینکه سیاست اجرا اجازه اجرای اسکریپت‌ها را می‌دهد (ویندوز)
   - تلاش برای ایجاد یک محیط مجازی جدید

2. **شکست در نصب بسته**:
   - تأیید فعال بودن محیط مجازی
   - بررسی اتصال اینترنت
   - به‌روزرسانی pip: `python -m pip install --upgrade pip`

3. **نسخه اشتباه پایتون**:
   - حذف محیط مجازی
   - ایجاد محیط جدید با نسخه صحیح پایتون
   - نصب مجدد وابستگی‌ها

## ساختار پروژه
```
micro_py_framework/
├── app.py                 # نقطه ورود اصلی برنامه
├── controller/            # پوشه کنترلرها
│   ├── UserController.py  # عملیات مربوط به کاربر
│   └── AutoController.py  # عملیات مربوط به خودرو
├── model/                # پوشه مدل‌ها
│   ├── UserModel.py      # عملیات داده کاربر
│   └── AutoModel.py      # عملیات داده خودرو
├── table/                # جداول پایگاه داده
│   ├── DBConnection.py   # مدیریت اتصال پایگاه داده
│   ├── DBMigrate.py      # مهاجرت و طرح پایگاه داده
│   ├── UserTable.py      # طرح جدول کاربر
│   └── AutoTable.py      # طرح جدول خودرو
├── interface/            # پوشه رابط‌ها
│   └── IController.py    # رابط کنترلر
└── helper/              # ابزارهای کمکی
    ├── HttpHandler.py    # مدیریت درخواست HTTP
    ├── Response.py       # فرمت‌بندی پاسخ
    ├── JWTManager.py     # احراز هویت JWT
    ├── FormatCheck.py    # اعتبارسنجی ورودی
    ├── CodeAssistant.py  # تولید کد با کمک هوش مصنوعی
    └── DatabaseMigration.py  # کمک‌کننده مهاجرت پایگاه داده
```

## نقاط پایانی API

### نقاط پایانی کنترلر کاربر

1. **ایجاد کاربر**
   - روش: POST
   - URL: `/user`
   - بدنه درخواست:
     ```json
     {
         "email": "user@example.com",
         "password": "password123",
         "name": "John Doe"
     }
     ```
   - پاسخ: پیام موفقیت یا جزئیات خطا

2. **دریافت کاربر(ها)**
   - روش: GET
   - URL: `/user` (لیست تمام کاربران)
   - URL: `/user/{id}` (دریافت کاربر خاص)
   - پاسخ: داده‌های کاربر یا پیام خطا

3. **به‌روزرسانی کاربر**
   - روش: PUT
   - URL: `/user`
   - بدنه درخواست:
     ```json
     {
         "id": 1,
         "name": "نام به‌روز شده",
         "password": "رمز جدید"  // اختیاری
     }
     ```
   - پاسخ: داده‌های به‌روز شده کاربر یا پیام خطا

4. **حذف کاربر**
   - روش: DELETE
   - URL: `/user`
   - بدنه درخواست:
     ```json
     {
         "id": 1
     }
     ```
   - پاسخ: پیام موفقیت یا جزئیات خطا

### نقاط پایانی کنترلر خودرو

1. **ایجاد خودرو**
   - روش: POST
   - URL: `/auto`
   - بدنه درخواست:
     ```json
     {
         "name": "Mercedes Benz",
         "ps": 750
     }
     ```
   - پاسخ: پیام موفقیت یا جزئیات خطا

2. **دریافت خودرو(ها)**
   - روش: GET
   - URL: `/auto` (لیست تمام خودروها)
   - URL: `/auto/{id}` (دریافت خودرو خاص)
   - پاسخ: داده‌های خودرو یا پیام خطا

3. **به‌روزرسانی خودرو**
   - روش: PUT
   - URL: `/auto`
   - بدنه درخواست:
     ```json
     {
         "id": 1,
         "name": "نام به‌روز شده",
         "ps": 800
     }
     ```
   - پاسخ: داده‌های به‌روز شده خودرو یا پیام خطا

4. **حذف خودرو**
   - روش: DELETE
   - URL: `/auto`
   - بدنه درخواست:
     ```json
     {
         "id": 1
     }
     ```
   - پاسخ: پیام موفقیت یا جزئیات خطا

## اعتبارسنجی داده

### قوانین اعتبارسنجی داده کاربر
- ایمیل: باید از فرمت استاندارد ایمیل پیروی کند
- رمز عبور: حداقل 6 کاراکتر
- نام: حداقل 2 کاراکتر

### قوانین اعتبارسنجی داده خودرو
- نام: حداقل 2 کاراکتر
- اسب بخار: باید یک عدد صحیح مثبت باشد

## پایگاه داده

### پایگاه داده SQLite
- برنامه از SQLite به عنوان پایگاه داده پیش‌فرض استفاده می‌کند
- فایل پایگاه داده: `db.db`
- جداول به طور خودکار در اولین اجرا ایجاد می‌شوند

### مهاجرت پایگاه داده (DatabaseMigration.py)
فایل `DatabaseMigration.py` مسئول مقداردهی اولیه خودکار پایگاه داده و ایجاد جداول است. این فایل موارد زیر را مدیریت می‌کند:

1. **اتصال پایگاه داده**
   - ایجاد اتصال به پایگاه داده SQLite (`db.db`)
   - مدیریت مکان‌نما پایگاه داده برای دستورات SQL
   - استفاده از SQLAlchemy برای عملیات پایگاه داده

2. **ایجاد خودکار جداول**
   - تشخیص و ایجاد خودکار تمام جداول تعریف شده در پوشه `table`
   - استفاده از مدل‌های SQLAlchemy برای تعریف ساختار جداول
   - مدیریت جداول فعلی مانند:
     - `users`: ذخیره اطلاعات کاربر با ایمیل، رمز عبور و نام
     - `autos`: ذخیره اطلاعات خودرو با نام و قدرت (اسب بخار)
   - نیازی به ایجاد دستی SQL نیست - جداول از تعاریف مدل ایجاد می‌شوند

3. **ویژگی‌های مهاجرت**
   - تشخیص و ایجاد خودکار جداول
   - تشخیص تغییرات ستون
   - پیگیری وضعیت مهاجرت
   - نشانگرهای پیشرفت واضح با ایموجی‌ها
   - خلاصه مهاجرت دقیق
   - خروجی نمونه:
     ```
     🚀 شروع مهاجرت پایگاه داده...
     📝 ایجاد جدول: users
     📝 ایجاد جدول: autos
     
     ✅ جداول با موفقیت ایجاد شدند:
       - users
       - autos
     
     === خلاصه مهاجرت ===
     📦 جداول ایجاد شده:
       ✓ users
       ✓ autos
     
     ✨ فرآیند مهاجرت تکمیل شد!
     ```

4. **اسکریپت مهاجرت (migrate.py)**
   به سادگی migrate.py را در پوشه ریشه باز کنید و اجرا کنید، یا در ترمینال در پوشه ریشه پروژه بنویسید python migrate.py!
   
   ویژگی‌ها:
   - ایجاد خودکار جداول از تعاریف مدل
   - پیگیری نسخه‌های طرح
   - تشخیص تغییرات ستون
   - نشانگرهای پیشرفت واضح
   - تولید خلاصه مهاجرت
   - مدیریت خطا با پیام‌های توصیفی

5. **مزایای اصلی**
   - نیازی به نوشتن دستی SQL نیست
   - طرح پایگاه داده یکنواخت در تمام نصب‌ها
   - به‌روزرسانی خودکار طرح هنگام تغییر مدل‌ها
   - بازخورد واضح در طول فرآیند مهاجرت
   - تشخیص و گزارش خطا
   - فرآیند مهاجرت ایمن با پشتیبانی از بازگشت

### مدیریت اتصال پایگاه داده (DBConnection.py)
فایل `DBConnection.py` اتصالات پایگاه داده را با استفاده از SQLAlchemy ORM مدیریت می‌کند. این فایل موارد زیر را فراهم می‌کند:

1. **ادغام SQLAlchemy**
   - استفاده از SQLAlchemy برای Object-Relational Mapping (ORM)
   - ارائه پایه اعلانی برای تعاریف مدل
   - مدیریت کارآمد نشست‌های پایگاه داده

2. **پیکربندی اتصال**
   ```python
   engine = create_engine("sqlite:///db.db", echo=False)
   ```
   - پیکربندی پیش‌فرض از پایگاه داده SQLite استفاده می‌کند
   - پشتیبانی از MySQL/MariaDB از طریق تغییر رشته اتصال
   - `echo=False` غیرفعال کردن ثبت پرس و جوهای SQL برای عملکرد بهتر

3. **مدیریت نشست**
   ```python
   Session = sessionmaker(bind=engine)
   ```
   - ایجاد کارخانه نشست برای عملیات پایگاه داده
   - مدیریت اتصالات و تراکنش‌های پایگاه داده
   - ارائه دسترسی امن به پایگاه داده برای رشته‌ها

4. **پشتیبانی پایگاه داده**
   - **SQLite** (پیش‌فرض):
     ```python
     engine = create_engine("sqlite:///db.db")
     ```
   - **MySQL/MariaDB**:
     ```python
     engine = create_engine("mysql+pymysql://نام_کاربر:رمز_عبور@localhost:3306/نام_پایگاه_داده")
     ```

5. **مدیریت خطا**
   - گرفتن و گزارش خطاهای اتصال پایگاه داده
   - ارائه پیام‌های خطای واضح برای عیب‌یابی

6. **استفاده در مدل‌ها**
   ```python
   from table.DBConnection import DBConnection
   
   class مدل_شما:
       def __init__(self):
           self.Session = DBConnection.Session
   ```

7. **بهترین شیوه‌ها**
   - استفاده از اتصال گروهی برای عملکرد بهتر
   - پیاده‌سازی مدیریت نشست مناسب
   - پشتیبانی از چندین بک‌اند پایگاه داده
   - پیروی از بهترین شیوه‌های SQLAlchemy

### پشتیبانی MySQL
- این فریم‌ورک از پایگاه داده‌های MySQL نیز پشتیبانی می‌کند
- برای استفاده از MySQL، رشته اتصال را در `table/DBConnection.py` تغییر دهید:
  ```python
  engine = create_engine("mysql+pymysql://نام_کاربر:رمز_عبور@localhost:3306/نام_پایگاه_داده")
  ```

## مدیریت خطا
این فریم‌ورک شامل مدیریت خطای جامع برای موارد زیر است:
- داده ورودی نامعتبر
- عملیات پایگاه داده
- اعتبارسنجی درخواست HTTP
- منبع یافت نشد
- اعتبارسنجی نوع داده
- فیلدهای الزامی گم شده

## نکات امنیتی
1. این یک فریم‌ورک آموزشی است و برای استفاده در محیط تولید توصیه نمی‌شود
2. هش کردن رمز عبور با استفاده از bcrypt پیاده‌سازی شده است
3. اعتبارسنجی ورودی پایه از طریق FormatCheck.py ارائه می‌شود
4. احراز هویت JWT از طریق JWTManager.py در دسترس است
5. هیچ سیستم احراز هویت/مجوزدهی داخلی وجود ندارد

## اعتبارسنجی ورودی
این فریم‌ورک شامل یک ابزار FormatCheck برای اعتبارسنجی داده ورودی است:

1. **اعتبارسنجی ایمیل**
   ```python
   FormatCheck.email("user@example.com")
   ```
   - استفاده از الگوی regex: `^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-z]+$`
   - اعتبارسنجی:
     - بخش نام کاربری: حروف، اعداد، نقطه، زیرخط، علامت مثبت، خط تیره
     - بخش دامنه: حروف، اعداد، خط تیره
     - TLD: فقط حروف
   - برمی‌گرداند: True اگر معتبر باشد، False در غیر این صورت

2. **اعتبارسنجی طول**
   ```python
   FormatCheck.minimumLength("رمز عبور", 6)
   ```
   - بررسی می‌کند که آیا رشته حداقل طول مورد نیاز را دارد
   - پارامترها:
     - input_string: رشته برای اعتبارسنجی
     - min_length: حداقل طول مورد نیاز
   - برمی‌گرداند: True اگر طول >= min_length باشد، False در غیر این صورت

3. **نمونه‌های استفاده**
   ```python
   # اعتبارسنجی ایمیل
   if not FormatCheck.email(user_email):
       return Response.bad_request("فرمت ایمیل نامعتبر است")

   # بررسی طول رمز عبور
   if not FormatCheck.minimumLength(password, 6):
       return Response.bad_request("رمز عبور باید حداقل 6 کاراکتر باشد")

   # بررسی طول نام
   if not FormatCheck.minimumLength(name, 2):
       return Response.bad_request("نام باید حداقل 2 کاراکتر باشد")
   ```

4. **قوانین اعتبارسنجی**
   - ایمیل: باید از فرمت استاندارد ایمیل با کاراکترهای معتبر پیروی کند
   - رمز عبور: حداقل 6 کاراکتر
   - نام: حداقل 2 کاراکتر

## نمونه استفاده

### ایجاد خودرو جدید
```bash
curl -X POST http://localhost:8001/auto \
  -H "Content-Type: application/json" \
  -d '{"name": "Mercedes Benz", "ps": 750}'
```

### دریافت تمام خودروها
```bash
curl http://localhost:8001/auto
```

### دریافت خودرو خاص
```bash
curl http://localhost:8001/auto/1
```

### به‌روزرسانی خودرو
```bash
curl -X PUT http://localhost:8001/auto \
  -H "Content-Type: application/json" \
  -d '{"id": 1, "name": "نام به‌روز شده", "ps": 800}'
```

### حذف خودرو
```bash
curl -X DELETE http://localhost:8001/auto \
  -H "Content-Type: application/json" \
  -d '{"id": 1}'
```

## مجموعه Postman
این فریم‌ورک شامل یک مجموعه Postman (`Micro Python.postman_collection.json`) است که درخواست‌های از پیش پیکربندی شده برای نقاط پایانی نمونه API را شامل می‌شود. این امر تست API را بدون نیاز به نوشتن دستورات curl آسان می‌کند.

### وارد کردن مجموعه
1. Postman را باز کنید
2. روی دکمه "Import" در گوشه سمت چپ بالا کلیک کنید
3. تب "File" را انتخاب کنید
4. روی "Upload Files" کلیک کنید و `Micro Python.postman_collection.json` را انتخاب کنید
5. روی "Import" کلیک کنید

### استفاده از مجموعه
این مجموعه شامل درخواست‌های از پیش پیکربندی شده زیر است:

#### نقاط پایانی خودرو
- **GET /auto**: لیست تمام خودروها
- **POST /auto**: ایجاد خودرو جدید
  - Body: JSON با فیلدهای `name` و `ps`
- **PUT /auto**: به‌روزرسانی خودرو موجود
  - Body: JSON با فیلدهای `id`، `name` و `ps`
- **DELETE /auto**: حذف خودرو
  - Body: JSON با فیلد `id`

### ویژگی‌های مجموعه
- هدرهای از پیش پیکربندی شده (Content-Type: application/json)
- بدنه‌های درخواست نمونه
- ساختار پوشه سازماندهی شده
- پشتیبانی از متغیرهای محیطی
- مستندات برای هر نقطه پایانی

### نکات برای استفاده از Postman
1. **تنظیم محیط**
   - ایجاد محیط جدید
   - اضافه کردن متغیر `base_url` با مقدار `http://localhost:8001`
   - استفاده از `{{base_url}}` در URLهای درخواست

2. **گردش کار تست**
   - شروع با درخواست‌های GET برای مشاهده داده‌ها
   - استفاده از POST برای ایجاد ورودی‌های جدید
   - استفاده از PUT برای تغییر ورودی‌های موجود
   - استفاده از DELETE برای حذف ورودی‌ها

3. **مدیریت پاسخ**
   - بررسی کدهای وضعیت
   - مشاهده پاسخ‌های JSON فرمت شده
   - استفاده از اسکریپت‌های تست Postman برای خودکارسازی

## دستورالعمل‌های توسعه

### ایجاد کنترلرهای جدید
1. ایجاد فایل جدید در پوشه `controller`
2. پیاده‌سازی رابط `IController`
3. اضافه کردن متدهای کنترلر (get, post, put, destroy)

### ایجاد مدل‌های جدید
1. ایجاد فایل جدید در پوشه `model`
2. پیاده‌سازی رابط `IModel`
3. ایجاد جدول مربوطه در پوشه `table`
4. پیاده‌سازی عملیات پایگاه داده

## محدودیت‌ها
1. هیچ سیستم احراز هویت داخلی وجود ندارد
2. مدیریت خطای محدود
3. اعتبارسنجی ورودی پایه
4. هیچ محدودیت نرخ درخواستی وجود ندارد
5. هیچ سیستم ثبت داخلی وجود ندارد
6. هیچ مکانیزم کش داخلی وجود ندارد

## بهترین شیوه‌ها
1. همیشه از محیط مجازی استفاده کنید
2. کنترلرها را لاغر نگه دارید، منطق کسب و کار را به مدل‌ها منتقل کنید
3. داده‌های ورودی را قبل از پردازش اعتبارسنجی کنید
4. خطاهای پایگاه داده را به درستی مدیریت کنید
5. از کدهای وضعیت HTTP مناسب در پاسخ‌ها استفاده کنید
6. از الگوهای مدیریت خطای سازگار پیروی کنید
7. از اشاره‌های نوع برای وضوح کد بهتر استفاده کنید
8. نقاط پایانی API و نیازمندی‌های آنها را مستند کنید

## عیب‌یابی
1. در صورت شکست اتصال پایگاه داده:
   - بررسی وجود فایل پایگاه داده
   - تأیید اعتبار پایگاه داده (در صورت استفاده از MySQL)
   - بررسی مجوزهای پایگاه داده

2. در صورت شکست راه‌اندازی سرور:
   - بررسی در دسترس بودن پورت 8001
   - تأیید نصب تمام وابستگی‌ها
   - بررسی سازگاری نسخه پایتون

3. در صورت شکست درخواست‌ها:
   - بررسی فرمت درخواست
   - بررسی قوانین اعتبارسنجی ورودی
   - اطمینان از استفاده از متد HTTP صحیح
   - بررسی صحت تنظیم هدر Content-Type
   - بررسی ارائه فیلدهای الزامی

## چرخه حیات درخواست HTTP

### جریان کلی درخواست
```mermaid
graph TD
    A[درخواست کلاینت] --> B[HttpHandler]
    B --> C{اعتبارسنجی درخواست}
    C -->|معتبر| D[مسیریابی به کنترلر]
    C -->|نامعتبر| E[بازگشت خطای 400]
    D --> F[اجرای متد کنترلر]
    F --> G[پردازش عملیات مدل]
    G --> H[عملیات پایگاه داده]
    H --> I[فرمت‌بندی پاسخ]
    I --> J[ارسال پاسخ به کلاینت]
```

### جریان ایجاد کاربر
```mermaid
sequenceDiagram
    participant کلاینت
    participant HttpHandler
    participant UserController
    participant UserModel
    participant پایگاه_داده

    کلاینت->>HttpHandler: POST /user
    Note over HttpHandler: اعتبارسنجی درخواست
    HttpHandler->>UserController: مسیریابی به کنترلر
    UserController->>UserModel: create()
    UserModel->>UserModel: اعتبارسنجی ایمیل
    UserModel->>UserModel: هش کردن رمز عبور
    UserModel->>پایگاه_داده: پرس و جوی INSERT
    پایگاه_داده-->>UserModel: موفقیت
    UserModel-->>UserController: موفقیت
    UserController-->>HttpHandler: 200 OK
    HttpHandler-->>کلاینت: پاسخ
```

### جریان مدیریت خطا
```mermaid
graph TD
    A[وقوع خطا] --> B{نوع خطا}
    B -->|اعتبارسنجی| C[فرمت‌بندی خطای اعتبارسنجی]
    B -->|پایگاه داده| D[فرمت‌بندی خطای پایگاه داده]
    B -->|پیدا نشد| E[فرمت‌بندی خطای 404]
    C --> F[تنظیم کد وضعیت خطا]
    D --> F
    E --> F
    F --> G[ارسال پاسخ خطا]
```

### تعامل مؤلفه‌ها
```mermaid
graph LR
    A[HttpHandler] -->|مسیریابی| B[کنترلر]
    B -->|استفاده می‌کند| C[مدل‌ها]
    C -->|تعامل می‌کند| D[پایگاه داده]
    B -->|پیاده‌سازی می‌کند| E[رابط IController]
    C -->|پیاده‌سازی می‌کند| F[رابط IModel]
    D -->|مدیریت می‌شود توسط| G[DBConnection]
    D -->|طرح توسط| H[DBMigrate]
```

## فرمت پاسخ
تمام پاسخ‌های API از یک فرمت سازگار پیروی می‌کنند:

### پاسخ موفقیت
```json
{
    "status_code": 200,
    "status": "success",
    "message": {
        // داده‌های پاسخ
    }
}
```

### پاسخ خطا
```json
{
    "status_code": 400,
    "status": "error",
    "message": "توضیح خطا"
}
```

## ادغام VS Code
این فریم‌ورک شامل ویژگی‌های ادغام VS Code است:
1. اسنیپت‌های سفارشی برای تولید سریع کد
2. پشتیبانی IntelliSense برای مؤلفه‌های فریم‌ورک
3. افزونه‌های توصیه شده برای توسعه پایتون
4. فرمت‌بندی خودکار کد با Black
5. لینتینگ با Pylint
6. سازماندهی import
7. پشتیبانی تولید مستندات

## ویژگی‌های دستیار هوش مصنوعی

این فریم‌ورک شامل یک دستیار کد هوشمند است که می‌تواند در موارد زیر به شما کمک کند:
- تولید نقاط پایانی CRUD
- ارائه پیشنهادات کد
- تولید مستندات
- تحلیل کدبیس شما

### شروع کار با دستیار هوش مصنوعی

1. **اجرای دمو دستیار هوش مصنوعی**
   به سادگی فایل `ai.py` را در ترمینال خود اجرا کنید:
   ```bash
   python ai.py
   ```
   این به شما نمونه‌هایی از قابلیت‌های دستیار را نشان می‌دهد:
   - تولید نقاط پایانی CRUD برای یک منبع "Product"
   - نمایش پیشنهادات کد برای UserController
   - تولید مستندات برای کنترلرها

2. **درک خروجی دمو**
   وقتی `ai.py` را اجرا می‌کنید، خواهید دید:
   - نتایج تحلیل کدبیس
   - نقاط پایانی CRUD تولید شده برای یک منبع نمونه
   - پیشنهادات کد برای کارهای رایج
   - نمونه‌های مستندات تولید شده

3. **استفاده از کد تولید شده**
   دمو نمونه‌های کد کامل تولید می‌کند که می‌توانید:
   - در کنترلرهای خود کپی و استفاده کنید
   - به عنوان الگو برای منابع جدید استفاده کنید
   - برای درک الگوهای فریم‌ورک مطالعه کنید

4. **تولید مستندات**
   همچنین می‌توانید مستندات را برای مؤلفه‌های خاص تولید کنید:
   ```python
   # نمونه: تولید مستندات برای کنترلرها
   docs = assistant.generate_documentation("controller")
   print(docs)
   ```

### نکات مهم
- دستیار کدبیس شما را تحلیل می‌کند تا پیشنهادات مرتبط با زمینه ارائه دهد
- کد تولید شده باید بررسی و متناسب با نیازهای خاص شما سفارشی شود
- دستیار برای اهداف آموزشی طراحی شده است و ممکن است تمام موارد خاص را پوشش ندهد
- همیشه کد تولید شده را قبل از استفاده در تولید تست کنید

### گردش کار نمونه
1. `python ai.py` را اجرا کنید تا نمونه‌ها را ببینید
2. کد و مستندات تولید شده را بررسی کنید
3. از الگوهای نشان داده شده برای ایجاد منابع خود استفاده کنید
4. در صورت نیاز پیشنهادات کد دریافت کنید
5. مستندات را برای کد خود تولید کنید
6. کد تولید شده را بررسی و سفارشی کنید
7. پیاده‌سازی خود را تست کنید

به یاد داشته باشید: این یک فریم‌ورک آموزشی است. همیشه کد تولید شده را بررسی کنید و بفهمید چه کاری انجام می‌دهد قبل از استفاده از آن در پروژه خود.

## پیامی از توسعه‌دهنده

با تشکر از شما برای صرف وقت برای کاوش در این فریم‌ورک آموزشی! من این پروژه را ایجاد کردم تا به مبتدیان در درک مفاهیم اساسی توسعه وب و برنامه‌نویسی پایتون کمک کنم.

امیدوارم این فریم‌ورک به عنوان یک گام مفید در سفر یادگیری شما عمل کند. به یاد داشته باشید که هر متخصصی زمانی مبتدی بوده است، و کلید تسلط بر برنامه‌نویسی تمرین مداوم و کنجکاوی است.

موفق باشید در سفر یادگیری شما!

علی خورسندفرد
توسعه‌دهنده و مربی

</div>